name: Build & Release YTGet

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag Name to Release'
        required: true

permissions:
  contents: write

jobs:
  build:
    name: Build (${{ matrix.os }} - ${{ matrix.arch }})
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: windows-latest
            arch: x86_64
          - os: ubuntu-latest
            arch: x86_64
          - os: macos-latest
            arch: arm64
          - os: macos-15-intel
            arch: x86_64

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller

      - name: Download yt-dlp
        if: runner.os != 'macOS'
        shell: bash
        run: |
          set -euo pipefail
          if [[ "$RUNNER_OS" == "Windows" ]]; then
            curl -L -o yt-dlp.exe "https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp.exe"
          elif [[ "$RUNNER_OS" == "Linux" ]]; then
            curl -L -o yt-dlp "https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp"
            chmod +x yt-dlp
          fi

      - name: Download ffmpeg & ffprobe (robust)
        shell: bash
        run: |
          set -euo pipefail
          echo "Runner OS: $RUNNER_OS"

          if [[ "$RUNNER_OS" == "Windows" ]]; then
            WIN_URL="https://www.gyan.dev/ffmpeg/builds/ffmpeg-release-essentials.zip"
            echo "Downloading ffmpeg from $WIN_URL"
            curl -L -o ffmpeg.zip "$WIN_URL"
            powershell -Command "Expand-Archive -Path ffmpeg.zip -DestinationPath ffmpeg-extract"
            powershell -Command "Get-ChildItem -Path ffmpeg-extract -Recurse -Filter ffmpeg.exe | Select-Object -First 1 | ForEach-Object { Copy-Item -Path $_.FullName -Destination '.' }"
            powershell -Command "Get-ChildItem -Path ffmpeg-extract -Recurse -Filter ffprobe.exe | Select-Object -First 1 | ForEach-Object { Copy-Item -Path $_.FullName -Destination '.' }"
          elif [[ "$RUNNER_OS" == "Linux" ]]; then
            if command -v ffmpeg >/dev/null 2>&1 && command -v ffprobe >/dev/null 2>&1; then
              cp "$(which ffmpeg)" .
              cp "$(which ffprobe)" .
            else
              echo "Downloading static ffmpeg (johnvansickle) for Linux"
              curl -L -o ffmpeg.tar.xz "https://johnvansickle.com/ffmpeg/releases/ffmpeg-release-amd64-static.tar.xz"
              mkdir -p ffmpeg-extract
              tar -xJf ffmpeg.tar.xz -C ffmpeg-extract --strip-components=1
              cp ffmpeg-extract/ffmpeg .
              cp ffmpeg-extract/ffprobe .
              chmod +x ffmpeg ffprobe
            fi
          else
            # macOS
            if command -v ffmpeg >/dev/null 2>&1 && command -v ffprobe >/dev/null 2>&1; then
              cp "$(which ffmpeg)" .
              cp "$(which ffprobe)" .
            else
              echo "Downloading ffmpeg for macOS (evermeet)"
              curl -L -o ffmpeg.zip "https://evermeet.cx/ffmpeg/ffmpeg-8.0.zip"
              unzip -q ffmpeg.zip -d ffmpeg-extract
              chmod +x ffmpeg-extract/ffmpeg || true
              cp ffmpeg-extract/ffmpeg .
              if [[ -f ffmpeg-extract/ffprobe ]]; then
                chmod +x ffmpeg-extract/ffprobe || true
                cp ffmpeg-extract/ffprobe .
              fi
            fi
          fi

          # Sanity check
          if [[ -f ffmpeg ]] || [[ -f ffmpeg.exe ]]; then
            echo "ffmpeg ready"
            if [[ -f ffmpeg ]]; then ./ffmpeg --version | head -n1 || true; fi
            if [[ -f ffmpeg.exe ]]; then ./ffmpeg.exe --version | head -n1 || true; fi
          else
            echo "ERROR: ffmpeg binary not found after extraction"
            ls -la
            exit 1
          fi

      - name: Download PhantomJS (per-OS)
        shell: bash
        run: |
          set -euo pipefail
          WIN_URL="https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-2.1.1-windows.zip"
          MAC_URL="https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-2.1.1-macosx.zip"
          LINUX_URL="https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-2.1.1-linux-x86_64.tar.bz2"

          if [[ "$RUNNER_OS" == "Windows" ]]; then
            echo "Downloading PhantomJS for Windows"
            curl -L -o phantomjs-windows.zip "$WIN_URL"
            powershell -Command "Expand-Archive -Path phantomjs-windows.zip -DestinationPath phantomjs-windows"
            cp phantomjs-windows/phantomjs-2.1.1-windows/bin/phantomjs.exe ./phantomjs.exe
          elif [[ "$RUNNER_OS" == "Linux" ]]; then
            echo "Downloading PhantomJS for Linux"
            curl -L -o phantomjs-linux.tar.bz2 "$LINUX_URL"
            tar xjf phantomjs-linux.tar.bz2
            cp phantomjs-2.1.1-linux-x86_64/bin/phantomjs ./phantomjs
            chmod +x phantomjs
          else
            echo "Downloading PhantomJS for macOS"
            curl -L -o phantomjs-macos.zip "$MAC_URL"
            unzip -q phantomjs-macos.zip
            cp phantomjs-2.1.1-macosx/bin/phantomjs ./phantomjs
            chmod +x phantomjs
          fi

      - name: Install jq (Linux/macOS) for JSON parsing
        if: runner.os != 'Windows'
        shell: bash
        run: |
          set -euo pipefail
          if [[ "$RUNNER_OS" == "Linux" ]]; then
            sudo apt-get update
            sudo apt-get install -y jq unzip
          else
            # macOS: try brew, fallback to downloading jq binary if brew unavailable
            if command -v brew >/dev/null 2>&1; then
              brew install jq unzip || true
            else
              echo "Homebrew not found; attempting to install jq via curl"
              JQ_URL="https://github.com/stedolan/jq/releases/latest/download/jq-osx-amd64"
              if [ -w /usr/local/bin ]; then
                curl -L -o /usr/local/bin/jq "$JQ_URL"
                chmod +x /usr/local/bin/jq || true
              else
                curl -L -o /usr/bin/jq "$JQ_URL" || true
                chmod +x /usr/bin/jq || true
              fi
            fi
          fi

      - name: Download latest Deno (non-Windows)
        if: runner.os != 'Windows'
        shell: bash
        env:
          GITHUB_API: https://api.github.com/repos/denoland/deno/releases/latest
        run: |
          set -euo pipefail
          echo "Querying latest Deno release from $GITHUB_API"
          release_json=$(curl -sL "$GITHUB_API")
          if [[ -z "$release_json" ]]; then
            echo "Failed to fetch Deno release info"; exit 1
          fi

          ASSET_PATTERN=""
          if [[ "$RUNNER_OS" == "Linux" ]]; then
            if [[ "${{ matrix.arch }}" == "x86_64" ]]; then
              ASSET_PATTERN="deno-.*x86_64.*linux.*\\.zip|deno-x86_64-unknown-linux-gnu.zip"
            else
              ASSET_PATTERN="deno-.*aarch64.*linux.*\\.zip|deno-aarch64-unknown-linux-gnu.zip"
            fi
          elif [[ "$RUNNER_OS" == "macOS" ]]; then
            if [[ "${{ matrix.arch }}" == "arm64" ]]; then
              ASSET_PATTERN="deno-.*aarch64.*apple.*darwin.*\\.zip|deno-aarch64-apple-darwin.zip"
            else
              ASSET_PATTERN="deno-.*x86_64.*apple.*darwin.*\\.zip|deno-x86_64-apple-darwin.zip"
            fi
          fi

          asset_url=$(echo "$release_json" | jq -r --arg pattern "$ASSET_PATTERN" '
            .assets[] | select(.name | test($pattern; "i")) | .browser_download_url' | head -n1)

          if [[ -z "$asset_url" || "$asset_url" == "null" ]]; then
            echo "No matching Deno asset found for this runner/arch. Dumping assets for debugging:"
            echo "$release_json" | jq -r '.assets[].name'
            exit 1
          fi

          echo "Found Deno asset: $asset_url"
          curl -L -o deno.zip "$asset_url"
          unzip -q deno.zip -d deno-extract
          DENO_BIN=$(find deno-extract -type f -name deno -print -quit || true)
          if [[ -z "$DENO_BIN" ]]; then
            echo "Deno binary not found in archive"; ls -la deno-extract; exit 1
          fi
          cp "$DENO_BIN" .
          chmod +x deno
          echo "Deno placed at: $(pwd)/deno"
          ./deno --version || true

      - name: Download latest Deno (Windows)
        if: runner.os == 'Windows'
        shell: powershell
        env:
          GITHUB_API: https://api.github.com/repos/denoland/deno/releases/latest
        run: |
          $release = Invoke-RestMethod -Uri $env:GITHUB_API -UseBasicParsing
          if (-not $release) { Write-Error "Failed to fetch Deno release info"; exit 1 }
          $asset = $release.assets | Where-Object { $_.name -match "deno-.*windows.*\\.zip" } | Select-Object -First 1
          if (-not $asset) {
            $asset = $release.assets | Where-Object { $_.name -eq "deno-x86_64-pc-windows-msvc.zip" } | Select-Object -First 1
          }
          if (-not $asset) { Write-Error "No Windows Deno asset found in latest release"; exit 1 }
          $url = $asset.browser_download_url
          Write-Host "Downloading Deno from $url"
          Invoke-WebRequest -Uri $url -OutFile deno.zip
          Expand-Archive -Path deno.zip -DestinationPath deno-extract
          $deno = Get-ChildItem -Path deno-extract -Recurse -Filter deno.exe | Select-Object -First 1
          if ($null -eq $deno) { Write-Error "deno.exe not found in archive"; exit 1 }
          Copy-Item $deno.FullName -Destination . -Force
          Write-Host "Deno placed at: $(Resolve-Path .\deno.exe)"
          & .\deno.exe --version

      - name: Update Info.plist version (macOS only)
        if: startsWith(matrix.os, 'macos')
        shell: bash
        run: |
          VERSION="${{ github.event.inputs.tag }}"
          /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $VERSION" Info.plist
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $VERSION" Info.plist

      - name: Build application
        shell: bash
        run: |
          set -euo pipefail
          if [[ "$RUNNER_OS" == "macOS" ]]; then
            ICON="ytget_gui/icon.icns"
            APP_NAME="YTGet"
            pyinstaller --noconfirm --onedir --windowed \
              --name "$APP_NAME" \
              --icon "$ICON" \
              --clean --noupx \
              --version-file "version_info.txt" \
              --osx-bundle-identifier "com.erfannamira.ytget" \
              --hidden-import "PySide6.QtCore" \
              --hidden-import "PySide6.QtGui" \
              --hidden-import "PySide6.QtWidgets" \
              --hidden-import "requests" \
              --hidden-import "mutagen" \
              --hidden-import "PIL" \
              --hidden-import "webbrowser" \
              --hidden-import "mutagen.id3" \
              --hidden-import "mutagen.flac" \
              --hidden-import "browser_cookie3" \
              --hidden-import "browser_cookie3.chrome" \
              --hidden-import "browser_cookie3.firefox" \
              --hidden-import "browser_cookie3.edge" \
              --hidden-import "browser_cookie3.opera" \
              --hidden-import "browser_cookie3.common" \
              --hidden-import "browser_cookie3.safari" \
              --hidden-import "browser_cookie3.utils" \
              --add-data "ytget_gui:ytget_gui" \
              --add-data "ytget_gui/icon.icns:." \
              --add-data "ffmpeg:." \
              --add-data "ffprobe:." \
              --add-data "phantomjs:." \
              --add-data "deno:." \
              ytget_gui/main.py
            cp Info.plist "dist/$APP_NAME.app/Contents/Info.plist"
          else
            ICON="ytget_gui/icon.ico"
            pyinstaller --noconfirm --onedir --windowed \
              --name "YTGet" \
              --icon "$ICON" \
              --clean --noupx \
              --version-file "version_info.txt" \
              --hidden-import "PySide6.QtCore" \
              --hidden-import "PySide6.QtGui" \
              --hidden-import "PySide6.QtWidgets" \
              --hidden-import "requests" \
              --hidden-import "mutagen" \
              --hidden-import "PIL" \
              --hidden-import "webbrowser" \
              --hidden-import "mutagen.id3" \
              --hidden-import "mutagen.flac" \
              --hidden-import "browser_cookie3" \
              --hidden-import "browser_cookie3.chrome" \
              --hidden-import "browser_cookie3.firefox" \
              --hidden-import "browser_cookie3.edge" \
              --hidden-import "browser_cookie3.opera" \
              --hidden-import "browser_cookie3.common" \
              --hidden-import "browser_cookie3.safari" \
              --hidden-import "browser_cookie3.utils" \
              --add-data "ytget_gui:ytget_gui" \
              --add-data "ytget_gui/icon.ico:." \
              --add-data "yt-dlp${{ runner.os == 'Windows' && '.exe' || '' }}:." \
              --add-data "ffmpeg${{ runner.os == 'Windows' && '.exe' || '' }}:." \
              --add-data "ffprobe${{ runner.os == 'Windows' && '.exe' || '' }}:." \
              --add-data "phantomjs${{ runner.os == 'Windows' && '.exe' || '' }}:." \
              --add-data "deno${{ runner.os == 'Windows' && '.exe' || '' }}:." \
              ytget_gui/main.py
          fi

      - name: Smoke test (macOS only)
        if: startsWith(matrix.os, 'macos')
        shell: bash
        run: |
          EXEC="./dist/YTGet.app/Contents/MacOS/YTGet"
          if [ ! -f "$EXEC" ]; then
            echo "âŒ $EXEC not found"; exit 1
          fi
          "$EXEC" --version

      - name: Package build
        shell: bash
        run: |
          set -euo pipefail
          if [[ "$RUNNER_OS" == "Windows" ]]; then
            powershell Compress-Archive -Path dist/YTGet -DestinationPath YTGet-windows.zip -CompressionLevel Optimal
          elif [[ "$RUNNER_OS" == "Linux" ]]; then
            tar czf YTGet-linux.tar.gz -C dist YTGet
          else
            cd dist
            if [[ "${{ matrix.arch }}" == "arm64" ]]; then
              tar czf YTGet-macOS-arm64.tar.gz YTGet.app
            else
              tar czf YTGet-macOS-x86_64.tar.gz YTGet.app
            fi
            cd ..
          fi

      - name: Generate SHA-256 checksum
        shell: bash
        run: |
          set -euo pipefail
          if [[ "$RUNNER_OS" == "Windows" ]]; then
            certutil -hashfile YTGet-windows.zip SHA256 > YTGet-windows.sha256
          elif [[ "$RUNNER_OS" == "Linux" ]]; then
            shasum -a 256 YTGet-linux.tar.gz > YTGet-linux.sha256
          else
            if [[ "${{ matrix.arch }}" == "arm64" ]]; then
              shasum -a 256 dist/YTGet-macOS-arm64.tar.gz > dist/YTGet-macOS-arm64.sha256
            else
              shasum -a 256 dist/YTGet-macOS-x86_64.tar.gz > dist/YTGet-x86_64.sha256
            fi
          fi

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-${{ matrix.os }}-${{ matrix.arch }}
          path: |
            YTGet-*.*
            dist/YTGet-*.tar.gz
            dist/YTGet-*.sha256

  release:
    name: Create GitHub Release
    needs: build
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.event.inputs.tag || github.ref_name }}
          name: "${{ github.event.inputs.tag || github.ref_name }}"
          body_path: RELEASE_NOTES.md
          files: artifacts/**/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
